# Redis 高级篇 & Redisson 使用

## 1. Redis 常用数据结构以及功能
    - 列表(List)
    - 集合(Set)
    - 有序集合(SortedSet)
    - 哈希(Hash)
    - 发布订阅模式
    - 消息队列(Stream)
    - 地理空间(Geospatial)
    - HyperLogLog
    - 位图(bitmap)
    - 位域(bitfield)
--------------------------------------

## 2. 事务
### 基本特性

- **非原子性**: 与关系型数据库不同，Redis 事务不保证所有命令统一成功或统一失败
- **命令排队**: 在 `MULTI` 和 `EXEC` 之间所有命令被缓存到队列中
- **顺序执行**: 接收到 `EXEC` 命令后按顺序一次性执行所有命令

### 核心机制

1. **命令缓存**
    - 所有在 `MULTI` 后的命令不会立即执行
    - 命令被放入缓冲队列等待执行

2. **执行阶段**
    - 收到 `EXEC` 命令后开始执行事务
    - 即使某个命令失败，其他命令仍会继续执行

3. **错误处理**
    - 入队错误：语法错误会导致整个事务被取消
    - 执行错误：单个命令失败不影响其他命令执行

### 限制与特点

- **不支持回滚**: Redis 事务执行过程中不支持回滚操作
- **无隔离级别**: 由于 Redis 单线程特性，事务具有一定程度的隔离性
- **不保证原子性**: 不支持全成功或全失败的原子操作

### 示例流程
```bash
  MULTI
  OK
  INCR key1
  QUEUED 
  INCR key2
  QUEUED
  EXEC
```
### 适用场景

- 需要按顺序执行多个相关命令
- 对强一致性要求不高的场景
- 需要一定隔离性的批量操作

---------

## 3. 持久化
Redis 提供了两种主要的持久化机制，用于将内存中的数据保存到磁盘，防止进程退出后数据丢失。

### RDB (Redis Database)

#### 工作原理
- **快照方式**: 在指定时间间隔内，将内存中的数据集快照写入磁盘
- **二进制格式**: 生成紧凑的二进制文件，便于备份和恢复
- **fork子进程**: 通过 `fork` 创建子进程进行持久化，避免阻塞主进程

#### 配置选项
- `save 900 1`: 900秒内至少有1个key发生变化则触发快照
- `save 300 10`: 300秒内至少有10个key发生变化则触发快照
- `save 60 10000`: 60秒内至少有10000个key发生变化则触发快照

#### 优点
- 文件紧凑，适合备份和灾难恢复
- 性能较好，对Redis性能影响较小
- 恢复大数据集速度快

#### 缺点
- 数据安全性较低，可能丢失最后一次快照后的数据
- fork操作消耗较多时间和内存

### AOF (Append Only File)

#### 工作原理
- **追加日志**: 将每个写操作命令追加到 `appendonly.aof` 文件末尾
- **重放恢复**: 通过重新执行AOF文件中的命令来恢复数据
- **fsync策略**: 可配置不同的同步策略控制数据安全性

#### 配置选项
- `appendonly yes`: 开启AOF持久化
- `appendfsync always`: 每次写操作都同步到磁盘（最安全，性能最低）
- `appendfsync everysec`: 每秒同步一次（推荐，默认）
- `appendfsync no`: 由操作系统决定何时同步（性能最好，安全性最低）

#### AOF重写
- **自动触发**: 当AOF文件过大时自动压缩文件体积
- **BGREWRITEAOF命令**: 手动触发AOF重写
- **保留最小命令集**: 生成能够重建当前数据集的最小命令集合

#### 优点
- 数据安全性高，最多丢失1秒的数据（使用everysec策略）
- AOF文件易于理解和解析
- 支持后台重写，不会阻塞主线程

#### 缺点
- 文件通常比RDB文件大
- 恢复速度相对较慢
- 性能可能受同步策略影响

### 持久化策略选择

#### 同时启用
- 可以同时开启RDB和AOF，重启时AOF优先级更高
- 结合两者优势，既保证数据安全又便于备份

#### 单独使用
- **仅RDB**: 适合数据不敏感、可以容忍短时间数据丢失的场景
- **仅AOF**: 适合对数据完整性要求较高的应用

#### 关闭持久化
- 将Redis作为纯内存缓存使用
- 性能最高，但重启后数据完全丢失
------------------------

## 4. 主从集群
Redis 主从集群是一种数据复制架构，通过主节点(Master)和从节点(Slave)的配合，实现数据冗余、读写分离和高可用性。

### 架构原理

- **主节点(Master)**: 负责处理写操作和数据更新
- **从节点(Slave)**: 复制主节点数据，主要处理读操作
- **异步复制**: 主从之间采用异步复制机制，提升性能

### 数据复制机制

1. **全量复制**
    - 从节点初次连接主节点时触发
    - 主节点创建 `RDB` 快照文件并传输给从节点
    - 从节点清空旧数据并加载新数据

2. **增量复制**
    - 基于主节点的复制积压缓冲区(`repl-backlog-buffer`)
    - 只传输断线期间丢失的数据
    - 适用于网络短暂中断后的快速恢复

3. **无盘复制**
    - 主节点直接通过网络传输 `RDB` 数据，不落磁盘
    - 减少磁盘I/O，提升复制效率


### 读写分离

- **写操作**: 全部路由到主节点
- **读操作**: 可分配到从节点，减轻主节点压力
- **负载均衡**: 多个从节点可分担读请求

### 优势特点

- **数据冗余**: 提供数据备份，增强数据安全性
- **扩展性**: 通过增加从节点扩展读能力
- **故障恢复**: 主节点故障时可手动切换从节点为主节点
- **性能优化**: 读写分离提升整体性能

### 注意事项

- **延迟问题**: 异步复制可能导致从节点数据滞后
- **一致性**: 最终一致性，非强一致性保证
- **资源消耗**: 每个从节点都需要与主节点维持连接
------------------------------

## 5. 哨兵模式
Redis 哨兵模式（Sentinel）是一种高可用性解决方案，用于监控 Redis 主从集群的状态，并在主节点故障时自动进行故障转移。

### 核心功能

- **监控**: 持续监控主节点和从节点是否正常运行
- **通知**: 当被监控的 Redis 实例出现问题时，向管理员发送通知
- **自动故障转移**: 主节点故障时自动将一个从节点提升为新的主节点
- **配置提供者**: 客户端连接时提供当前主节点地址

### 工作原理

1. **多哨兵部署**: 通常部署奇数个哨兵实例（如3个或5个）
2. **主观下线**: 单个哨兵认为主节点不可用
3. **客观下线**: 多数哨兵达成共识，确认主节点确实不可用
4. **选举领导者**: 哨兵集群选举出一个领导者负责故障转移
5. **故障转移**: 选择合适的从节点晋升为新的主节点

#### 配置说明
- `sentinel monitor`: 监控主节点，最后数字表示判断主节点下线所需的哨兵数量
- `sentinel down-after-milliseconds`: 判断实例下线前等待的毫秒数
- `sentinel failover-timeout`: 故障转移超时时间
- `sentinel parallel-syncs`: 故障转移后，同时进行同步的从节点数量

### 故障转移过程

1. **检测故障**: 哨兵检测到主节点主观下线
2. **协商确认**: 多个哨兵确认主节点客观下线
3. **选举领导**: 选出负责故障转移的哨兵领导者
4. **选择从节点**: 从从节点中选择最优节点作为新主节点
5. **执行晋升**: 将选中的从节点提升为主节点
6. **重新配置**: 让其他从节点复制新的主节点
7. **通知客户端**: 更新主节点信息并通知客户端

### 优势特点

- **自动运维**: 无需人工干预即可完成故障转移
- **高可用性**: 保证服务持续可用
- **分布式监控**: 多哨兵部署避免单点故障
- **灵活配置**: 可根据业务需求调整故障检测参数

### 注意事项

- **网络分区**: 需要考虑网络分割情况下的脑裂问题
- **从节点延迟**: 故障转移可能丢失少量数据
- **客户端支持**: 客户端需支持哨兵模式连接方式
- **资源配置**: 哨兵实例需要独立的系统资源

---------------

# 总结
```text
部署过程中踩的坑: 当哨兵通过 master 获取 redis 集群时, 获取到的 host 是 docker 容器中的 ip 地址, 导致一直 ping 不通从而导致哨兵集群启动失败
解决方法: 显式配置 redis 节点对外暴漏的 ip 地址和端口, 其实不推荐使用 docker 搭建集群环境, 生产环境中都是使用物理机来搭建集群的.
```